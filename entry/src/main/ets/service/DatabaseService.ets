import { preferences } from '@kit.ArkData';
import { AudioRecord, AudioGroup } from '../model/DataModel';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { common } from '@kit.AbilityKit';

const TAG = 'DatabaseService';
const DOMAIN = 0x0000;

/**
 * éŸ³é¢‘è®°å½•è¾“å…¥æ¥å£ï¼ˆä¸åŒ…å«idå­—æ®µï¼‰
 */
export interface AudioRecordInput {
  fileName: string;
  filePath: string;
  duration: number;
  fileSize: number;
  createTime: number;
  isTop: boolean;
  groupId?: number;
}

/**
 * æ•°æ®åº“æœåŠ¡ç±»
 * è´Ÿè´£éŸ³é¢‘è®°å½•å’Œåˆ†ç»„çš„æ•°æ®åº“æ“ä½œ
 * ä½¿ç”¨preferenceså­˜å‚¨æ›¿ä»£relationalStore
 */
export class DatabaseService {
  private static instance: DatabaseService;
  private dataPreferences: preferences.Preferences | null = null;
  private readonly PREF_NAME = 'AudioDiaryData';
  private readonly RECORDS_KEY = 'audio_records';
  private readonly GROUPS_KEY = 'audio_groups';
  private readonly NEXT_RECORD_ID_KEY = 'next_record_id';
  private readonly NEXT_GROUP_ID_KEY = 'next_group_id';

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  public async initDatabase(context: Context | common.UIAbilityContext): Promise<void> {
    const timestamp = new Date().toISOString();
    try {
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ”„ å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“`);
      
      this.dataPreferences = await preferences.getPreferences(context, this.PREF_NAME);
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… Preferenceså¯¹è±¡åˆ›å»ºæˆåŠŸ`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šéªŒè¯preferenceså¯¹è±¡æ˜¯å¦æœ‰æ•ˆ
      if (!this.dataPreferences) {
        throw new Error('Preferenceså¯¹è±¡åˆ›å»ºå¤±è´¥ï¼Œè¿”å›null');
      }
      
      await this.initDefaultData();
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… é»˜è®¤æ•°æ®åˆå§‹åŒ–å®Œæˆ`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šéªŒè¯æ•°æ®åº“æ˜¯å¦çœŸçš„å¯ç”¨
      const testRecords = await this.getAllRecords();
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… æ•°æ®åº“éªŒè¯æˆåŠŸï¼Œå½“å‰è®°å½•æ•°: ${testRecords.length}`);
      
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ‰ æ•°æ®åº“åˆå§‹åŒ–å®Œå…¨æˆåŠŸ`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(error)}`);
      this.dataPreferences = null; // ç¡®ä¿æ¸…ç†çŠ¶æ€
      throw new Error(`æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤æ•°æ®
   */
  private async initDefaultData(): Promise<void> {
    if (!this.dataPreferences) return;

    // åˆå§‹åŒ–åˆ†ç»„æ•°æ® - ä¸åˆ›å»ºé»˜è®¤åˆ†ç»„ï¼Œè®©ç”¨æˆ·è‡ªå·±åˆ›å»º
    const groups = await this.getAllGroups();
    if (groups.length === 0) {
      await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify([]));
      await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, 1);
    }

    // åˆå§‹åŒ–è®°å½•æ•°æ®å¹¶è¿›è¡Œæ•°æ®è¿ç§»
    const records = await this.getAllRecords();
    if (records.length === 0) {
      await this.dataPreferences.put(this.RECORDS_KEY, JSON.stringify([]));
      await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, 1);
    } else {
      // ğŸ”¥ æ•°æ®è¿ç§»ï¼šå°†æ—§çš„groupIdè½¬æ¢ä¸ºgroupIdsæ•°ç»„
      let needsMigration = false;
      const migratedRecords = records.map(record => {
        if (record.groupId !== undefined && !record.groupIds) {
          needsMigration = true;
          // å¦‚æœæœ‰groupIdä½†æ²¡æœ‰groupIdsï¼Œè¿›è¡Œè¿ç§»
          const migratedRecord: AudioRecord = {
            id: record.id,
            fileName: record.fileName,
            filePath: record.filePath,
            duration: record.duration,
            fileSize: record.fileSize,
            createTime: record.createTime,
            isTop: record.isTop,
            groupId: record.groupId,
            groupIds: record.groupId ? [record.groupId] : []
          };
          return migratedRecord;
        } else if (!record.groupIds) {
          // å¦‚æœæ—¢æ²¡æœ‰groupIdä¹Ÿæ²¡æœ‰groupIdsï¼Œåˆå§‹åŒ–ä¸ºç©ºæ•°ç»„
          needsMigration = true;
          const migratedRecord: AudioRecord = {
            id: record.id,
            fileName: record.fileName,
            filePath: record.filePath,
            duration: record.duration,
            fileSize: record.fileSize,
            createTime: record.createTime,
            isTop: record.isTop,
            groupId: record.groupId,
            groupIds: []
          };
          return migratedRecord;
        }
        return record;
      });
      
      if (needsMigration) {
        hilog.info(DOMAIN, TAG, 'æ‰§è¡Œæ•°æ®è¿ç§»ï¼šgroupId -> groupIds');
        await this.saveRecords(migratedRecords);
      }
    }

    await this.dataPreferences.flush();
  }

  /**
   * è·å–æ‰€æœ‰è®°å½•
   */
  private async getAllRecords(): Promise<AudioRecord[]> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ” getAllRecords() å¼€å§‹ä»æ•°æ®åº“è¯»å–è®°å½•`);
    
    if (!this.dataPreferences) {
      hilog.warn(DOMAIN, TAG, `[${timestamp}] âš ï¸ dataPreferencesæœªåˆå§‹åŒ–ï¼Œè¿”å›ç©ºæ•°ç»„`);
      return [];
    }
    
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ è°ƒç”¨dataPreferences.get()è¯»å–è®°å½•æ•°æ®`);
    const recordsStr = await this.dataPreferences.get(this.RECORDS_KEY, '[]') as string;
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š ä»å­˜å‚¨ä¸­è·å–åˆ°çš„åŸå§‹æ•°æ®é•¿åº¦: ${recordsStr.length}å­—ç¬¦`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ åŸå§‹æ•°æ®å†…å®¹é¢„è§ˆ: ${recordsStr.substring(0, 200)}${recordsStr.length > 200 ? '...' : ''}`);
    
    try {
      const records = JSON.parse(recordsStr) as AudioRecord[];
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… JSONè§£ææˆåŠŸï¼Œè·å–åˆ° ${records.length} æ¡è®°å½•`);
      
      if (records.length > 0) {
        hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“‹ è®°å½•è¯¦æƒ…é¢„è§ˆ:`);
        records.slice(0, 2).forEach((record, index) => {
          hilog.info(DOMAIN, TAG, `[${timestamp}]   è®°å½•${index + 1}: ID=${record.id}, æ–‡ä»¶å='${record.fileName}', æ—¶é•¿=${record.duration}ms`);
        });
      }
      
      return records;
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ JSONè§£æå¤±è´¥: ${JSON.stringify(error)}`);
      hilog.error(DOMAIN, TAG, `[${timestamp}] åŸå§‹æ•°æ®: ${recordsStr}`);
      return [];
    }
  }

  /**
   * è·å–æ‰€æœ‰åˆ†ç»„
   */
  public async getAllGroups(): Promise<AudioGroup[]> {
    if (!this.dataPreferences) return [];
    
    const groupsStr = await this.dataPreferences.get(this.GROUPS_KEY, '[]') as string;
    return JSON.parse(groupsStr) as AudioGroup[];
  }

  /**
   * ä¿å­˜è®°å½•
   */
  private async saveRecords(records: AudioRecord[]): Promise<void> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ’¾ saveRecords() started, saving ${records.length} records`);
    
    if (!this.dataPreferences) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ Database not initialized`);
      return;
    }
    
    try {
      const recordsJson = JSON.stringify(records);
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ JSON data length: ${recordsJson.length} characters`);
      
      await this.dataPreferences.put(this.RECORDS_KEY, recordsJson);
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… Records saved to preferences`);
      
      await this.dataPreferences.flush();
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… Data flushed to storage`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šéªŒè¯æ•°æ®æ˜¯å¦çœŸçš„è¢«ä¿å­˜
      const verifyJson = await this.dataPreferences.get(this.RECORDS_KEY, '');
      if (verifyJson === recordsJson) {
        hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… æ•°æ®ä¿å­˜éªŒè¯æˆåŠŸ`);
      } else {
        hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ æ•°æ®ä¿å­˜éªŒè¯å¤±è´¥`);
      }
      
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ Failed to save records: ${JSON.stringify(error)}`);
      throw new Error(`Failed to save records: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * ä¿å­˜åˆ†ç»„
   */
  private async saveGroups(groups: AudioGroup[]): Promise<void> {
    if (!this.dataPreferences) return;
    
    await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify(groups));
    await this.dataPreferences.flush();
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªè®°å½•ID
   */
  private async getNextRecordId(): Promise<number> {
    if (!this.dataPreferences) return 1;
    
    const nextId = await this.dataPreferences.get(this.NEXT_RECORD_ID_KEY, 1) as number;
    await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, nextId + 1);
    await this.dataPreferences.flush();
    return nextId;
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªåˆ†ç»„ID
   */
  private async getNextGroupId(): Promise<number> {
    if (!this.dataPreferences) return 1;
    
    const nextId = await this.dataPreferences.get(this.NEXT_GROUP_ID_KEY, 1) as number;
    await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, nextId + 1);
    await this.dataPreferences.flush();
    return nextId;
  }

  // ==================== éŸ³é¢‘è®°å½•æ“ä½œ ====================

  /**
   * æ’å…¥éŸ³é¢‘è®°å½•
   */
  public async insertAudioRecord(record: AudioRecordInput): Promise<number> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] insertAudioRecord() started, params: ${JSON.stringify(record)}`);
    
    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šéªŒè¯æ•°æ®åº“è¿æ¥çŠ¶æ€
    if (!this.dataPreferences) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ Database not initialized - dataPreferences is null`);
      throw new Error('Database not initialized - dataPreferences is null');
    }
    
    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæµ‹è¯•æ•°æ®åº“è¿æ¥æ˜¯å¦å¯ç”¨
    try {
      await this.dataPreferences.flush();
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… æ•°æ®åº“è¿æ¥éªŒè¯æˆåŠŸ`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ æ•°æ®åº“è¿æ¥éªŒè¯å¤±è´¥: ${JSON.stringify(error)}`);
      throw new Error(`æ•°æ®åº“è¿æ¥ä¸å¯ç”¨: ${JSON.stringify(error)}`);
    }
    hilog.info(DOMAIN, TAG, `[${timestamp}] Database initialized, starting to get all records`);

    const records = await this.getAllRecords();
    hilog.info(DOMAIN, TAG, `[${timestamp}] Got ${records.length} existing records`);
    
    const newId = await this.getNextRecordId();
    hilog.info(DOMAIN, TAG, `[${timestamp}] Generated new record ID: ${newId}`);
    
    const newRecord: AudioRecord = {
      id: newId,
      fileName: record.fileName,
      filePath: record.filePath,
      duration: record.duration,
      fileSize: record.fileSize,
      createTime: record.createTime,
      isTop: record.isTop,
      groupId: record.groupId || 0, // 0è¡¨ç¤ºæœªåˆ†ç»„ï¼ˆå‘åå…¼å®¹ï¼‰
      groupIds: record.groupId ? [record.groupId] : [] // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šåˆå§‹åŒ–groupIdsæ•°ç»„
    };
    hilog.info(DOMAIN, TAG, `[${timestamp}] Created new record object: ${JSON.stringify(newRecord)}`);

    records.push(newRecord);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Added new record to list, current total: ${records.length}`);
    
    await this.saveRecords(records);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Record saved successfully`);
    
    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç«‹å³éªŒè¯æ•°æ®æ˜¯å¦çœŸçš„è¢«ä¿å­˜
    const verifyRecords = await this.getAllRecords();
    const savedRecord = verifyRecords.find(r => r.id === newId);
    if (savedRecord) {
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… æ•°æ®ä¿å­˜éªŒè¯æˆåŠŸï¼Œæ‰¾åˆ°æ–°ä¿å­˜çš„è®°å½•: ID=${savedRecord.id}, æ–‡ä»¶å='${savedRecord.fileName}'`);
    } else {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ æ•°æ®ä¿å­˜éªŒè¯å¤±è´¥ï¼Œæœªæ‰¾åˆ°æ–°ä¿å­˜çš„è®°å½•ï¼`);
      throw new Error('æ•°æ®ä¿å­˜éªŒè¯å¤±è´¥');
    }
    
    // æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡
    if (newRecord.groupId) {
      hilog.info(DOMAIN, TAG, `[${timestamp}] Starting to update audio count for group ${newRecord.groupId}`);
      await this.updateGroupAudioCount(newRecord.groupId);
      hilog.info(DOMAIN, TAG, `[${timestamp}] Group audio count update completed`);
    }

    hilog.info(DOMAIN, TAG, `[${timestamp}] insertAudioRecord() executed successfully, returning ID: ${newId}`);
    return newId;
  }

  /**
   * æŸ¥è¯¢æ‰€æœ‰éŸ³é¢‘è®°å½•
   */
  public async queryAllAudioRecords(): Promise<AudioRecord[]> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ” queryAllAudioRecords() å¼€å§‹æŸ¥è¯¢æ‰€æœ‰éŸ³é¢‘è®°å½•`);
    
    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶åˆ·æ–°æ•°æ®å­˜å‚¨ï¼Œç¡®ä¿è·å–æœ€æ–°æ•°æ®
    if (this.dataPreferences) {
      await this.dataPreferences.flush();
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ’¾ å¼ºåˆ¶åˆ·æ–°æ•°æ®å­˜å‚¨å®Œæˆ`);
    }
    
    const records = await this.getAllRecords();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š ä»æ•°æ®åº“è·å–åˆ° ${records.length} æ¡éŸ³é¢‘è®°å½•`);
    
    if (records.length > 0) {
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æœ€æ–°çš„3æ¡è®°å½•è¯¦æƒ…:`);
      records.slice(0, 3).forEach((record, index) => {
        hilog.info(DOMAIN, TAG, `[${timestamp}] è®°å½•${index + 1}: ID=${record.id}, æ–‡ä»¶å='${record.fileName}', åˆ›å»ºæ—¶é—´=${new Date(record.createTime).toLocaleString()}`);
      });
    } else {
      hilog.warn(DOMAIN, TAG, `[${timestamp}] âš ï¸ æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•éŸ³é¢‘è®°å½•`);
    }
    
    const sortedRecords = records.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
    
    hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… éŸ³é¢‘è®°å½•æ’åºå®Œæˆï¼Œè¿”å› ${sortedRecords.length} æ¡è®°å½•`);
    return sortedRecords;
  }

  /**
   * æ ¹æ®å…³é”®è¯æœç´¢éŸ³é¢‘è®°å½•
   */
  public async searchAudioRecords(keyword: string): Promise<AudioRecord[]> {
    const records = await this.getAllRecords();
    const filteredRecords = records.filter(record => 
      record.fileName.toLowerCase().includes(keyword.toLowerCase())
    );
    
    return filteredRecords.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
  }

  /**
   * æ›´æ–°éŸ³é¢‘è®°å½•
   */
  public async updateAudioRecord(record: AudioRecord): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const index = records.findIndex(r => r.id === record.id);
    
    if (index !== -1) {
      records[index] = record;
      await this.saveRecords(records);
    }
  }

  /**
   * åˆ é™¤éŸ³é¢‘è®°å½•
   */
  public async deleteAudioRecord(id: number): Promise<void> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ—‘ï¸ deleteAudioRecord() started, ID: ${id}`);
    
    if (!this.dataPreferences) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ Database not initialized`);
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š å½“å‰æ•°æ®åº“ä¸­æœ‰ ${records.length} æ¡è®°å½•`);
    
    const recordIndex = records.findIndex(r => r.id === id);
    
    if (recordIndex !== -1) {
      const record = records[recordIndex];
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æ‰¾åˆ°è¦åˆ é™¤çš„è®°å½•: ID=${record.id}, æ–‡ä»¶å='${record.fileName}'`);
      
      records.splice(recordIndex, 1);
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ—‚ï¸ ä»åˆ—è¡¨ä¸­ç§»é™¤è®°å½•ï¼Œå‰©ä½™ ${records.length} æ¡è®°å½•`);
      
      await this.saveRecords(records);
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ’¾ è®°å½•å·²ä¿å­˜åˆ°æ•°æ®åº“`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç«‹å³éªŒè¯åˆ é™¤æ˜¯å¦æˆåŠŸ
      const verifyRecords = await this.getAllRecords();
      const deletedRecord = verifyRecords.find(r => r.id === id);
      if (!deletedRecord) {
        hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… åˆ é™¤éªŒè¯æˆåŠŸï¼Œè®°å½•å·²ä¸å­˜åœ¨`);
      } else {
        hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ åˆ é™¤éªŒè¯å¤±è´¥ï¼Œè®°å½•ä»ç„¶å­˜åœ¨`);
      }
      
      // æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡
      if (record.groupId) {
        hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š æ›´æ–°åˆ†ç»„ ${record.groupId} çš„éŸ³é¢‘æ•°é‡`);
        await this.updateGroupAudioCount(record.groupId);
      }
      
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… deleteAudioRecord() completed successfully`);
    } else {
      hilog.warn(DOMAIN, TAG, `[${timestamp}] âš ï¸ æœªæ‰¾åˆ°IDä¸º ${id} çš„è®°å½•`);
    }
  }

  /**
   * åˆ‡æ¢ç½®é¡¶çŠ¶æ€
   */
  public async toggleTopStatus(id: number, isTop: boolean): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const record = records.find(r => r.id === id);
    
    if (record) {
      record.isTop = isTop;
      await this.saveRecords(records);
    }
  }

  /**
   * æ ¹æ®IDè·å–éŸ³é¢‘è®°å½•
   */
  public async getAudioRecordById(id: number): Promise<AudioRecord | null> {
    const records = await this.getAllRecords();
    return records.find(r => r.id === id) || null;
  }

  /**
   * æ¸…ç†æŸåçš„æ•°æ®ï¼ˆä¿®å¤é‡å¤è®°å½•å’Œé”™è¯¯åˆ†ç»„ï¼‰
   */
  public async cleanupCorruptedData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    hilog.info(DOMAIN, TAG, 'Starting data cleanup...');
    
    // é¦–å…ˆæ¸…ç†æ¨¡æ‹Ÿæ•°æ®
    await this.cleanupMockData();
    
    // æ¸…ç†é‡å¤çš„éŸ³é¢‘è®°å½•
    const records = await this.getAllRecords();
    const uniqueRecords = new Map<string, AudioRecord>();
    
    // ä½¿ç”¨æ–‡ä»¶è·¯å¾„ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œä¿ç•™æœ€æ–°çš„è®°å½•
    records.forEach(record => {
      const key = record.filePath;
      if (!uniqueRecords.has(key) || record.createTime > uniqueRecords.get(key)!.createTime) {
        uniqueRecords.set(key, record);
      }
    });
    
    const cleanedRecords = Array.from(uniqueRecords.values());
    hilog.info(DOMAIN, TAG, `Removed ${records.length - cleanedRecords.length} duplicate records`);
    
    // æ¸…ç†æ— æ•ˆçš„åˆ†ç»„ï¼ˆåªä¿ç•™æœ‰éŸ³é¢‘è®°å½•çš„åˆ†ç»„ï¼‰
    const groups = await this.getAllGroups();
    const validGroupIds = new Set(cleanedRecords.map(r => r.groupId).filter(id => id && id > 0));
    const cleanedGroups = groups.filter(group => validGroupIds.has(group.id));
    
    hilog.info(DOMAIN, TAG, `Removed ${groups.length - cleanedGroups.length} invalid groups`);
    
    // ä¿å­˜æ¸…ç†åçš„æ•°æ®
    await this.saveRecords(cleanedRecords);
    await this.saveGroups(cleanedGroups);
    
    // é‡æ–°è®¡ç®—åˆ†ç»„éŸ³é¢‘æ•°é‡
    for (const group of cleanedGroups) {
      await this.updateGroupAudioCount(group.id);
    }
    
    hilog.info(DOMAIN, TAG, 'Data cleanup completed successfully');
  }

  /**
   * æ¸…ç†æ¨¡æ‹Ÿæ•°æ®
   * åˆ é™¤åŒ…å«æ¨¡æ‹Ÿã€æµ‹è¯•ã€ç¤ºä¾‹ç­‰å…³é”®è¯çš„éŸ³é¢‘è®°å½•
   */
  public async cleanupMockData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    hilog.info(DOMAIN, TAG, 'Starting mock data cleanup...');
    
    const records = await this.getAllRecords();
    const mockKeywords = ['mock', 'test', 'sample', 'æ¨¡æ‹Ÿ', 'æµ‹è¯•', 'ç¤ºä¾‹', 'æ¼”ç¤º'];
    
    // è¿‡æ»¤æ‰åŒ…å«æ¨¡æ‹Ÿå…³é”®è¯çš„è®°å½•
    const realRecords = records.filter(record => {
      const fileName = record.fileName.toLowerCase();
      const filePath = record.filePath.toLowerCase();
      
      // æ£€æŸ¥æ–‡ä»¶åå’Œè·¯å¾„æ˜¯å¦åŒ…å«æ¨¡æ‹Ÿå…³é”®è¯
      return !mockKeywords.some(keyword => 
        fileName.includes(keyword) || filePath.includes(keyword)
      );
    });
    
    const removedCount = records.length - realRecords.length;
    if (removedCount > 0) {
      await this.saveRecords(realRecords);
      hilog.info(DOMAIN, TAG, `Removed ${removedCount} mock data records`);
    } else {
      hilog.info(DOMAIN, TAG, 'No mock data found to clean');
    }
  }

  /**
   * æ¸…ç†æ‰€æœ‰æ•°æ®ï¼ˆç”¨äºè°ƒè¯•å’Œé‡ç½®ï¼‰
   */
  public async clearAllData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    // æ¸…ç©ºæ‰€æœ‰è®°å½•å’Œåˆ†ç»„
    await this.dataPreferences.put(this.RECORDS_KEY, JSON.stringify([]));
    await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify([]));
    
    // é‡ç½®IDè®¡æ•°å™¨
    await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, 1);
    await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, 1);
    
    await this.dataPreferences.flush();
    hilog.info(DOMAIN, TAG, 'All data cleared successfully');
  }

  // ==================== éŸ³é¢‘åˆ†ç»„æ“ä½œ ====================

  /**
   * åˆ›å»ºåˆ†ç»„
   */
  public async createGroup(groupName: string): Promise<number> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const groups = await this.getAllGroups();
    const newId = await this.getNextGroupId();
    
    const newGroup: AudioGroup = {
      id: newId,
      groupName: groupName,
      createTime: Date.now(),
      audioCount: 0
    };

    groups.push(newGroup);
    await this.saveGroups(groups);
    
    return newId;
  }

  /**
   * æŸ¥è¯¢æ‰€æœ‰åˆ†ç»„
   */
  public async queryAllGroups(): Promise<AudioGroup[]> {
    const groups = await this.getAllGroups();
    return groups.sort((a, b) => b.createTime - a.createTime);
  }

  /**
   * æ›´æ–°åˆ†ç»„åç§°
   */
  public async updateGroupName(id: number, newName: string): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const groups = await this.getAllGroups();
    const group = groups.find(g => g.id === id);
    
    if (group) {
      group.groupName = newName;
      await this.saveGroups(groups);
    }
  }

  /**
   * åˆ é™¤åˆ†ç»„
   */
  public async deleteGroup(id: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šä»æ‰€æœ‰éŸ³é¢‘çš„groupIdsä¸­ç§»é™¤è¯¥åˆ†ç»„ID
    const records = await this.getAllRecords();
    records.forEach(record => {
      // å¤„ç†æ–°ç‰ˆæœ¬çš„groupIdsæ•°ç»„
      if (record.groupIds && record.groupIds.includes(id)) {
        record.groupIds = record.groupIds.filter(gid => gid !== id);
      }
      // å…¼å®¹æ—§ç‰ˆæœ¬çš„groupId
      if (record.groupId === id) {
        record.groupId = undefined;
      }
    });
    await this.saveRecords(records);

    // åˆ é™¤åˆ†ç»„
    const groups = await this.getAllGroups();
    const groupIndex = groups.findIndex(g => g.id === id);
    if (groupIndex !== -1) {
      groups.splice(groupIndex, 1);
      await this.saveGroups(groups);
    }
  }

  /**
   * æ·»åŠ éŸ³é¢‘åˆ°åˆ†ç»„ï¼ˆæ”¯æŒå¤šåˆ†ç»„ï¼Œä¸ä¼šç§»é™¤å…¶ä»–åˆ†ç»„ï¼‰
   */
  public async addAudioToGroup(audioId: number, groupId: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const record = records.find(r => r.id === audioId);
    
    if (record) {
      // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šæ·»åŠ åˆ°groupIdsæ•°ç»„
      if (!record.groupIds) {
        record.groupIds = [];
      }
      
      // å¦‚æœè¯¥åˆ†ç»„ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œåˆ™æ·»åŠ 
      if (!record.groupIds.includes(groupId)) {
        record.groupIds.push(groupId);
        await this.saveRecords(records);
        
        // æ›´æ–°åˆ†ç»„çš„éŸ³é¢‘æ•°é‡
        await this.updateGroupAudioCount(groupId);
      }
    }
  }

  /**
   * ä»åˆ†ç»„ç§»é™¤éŸ³é¢‘
   */
  public async removeAudioFromGroup(audioId: number, groupId: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const record = records.find(r => r.id === audioId);
    
    if (record && record.groupIds) {
      // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šä»groupIdsæ•°ç»„ä¸­ç§»é™¤æŒ‡å®šåˆ†ç»„
      record.groupIds = record.groupIds.filter(gid => gid !== groupId);
      await this.saveRecords(records);
      
      // æ›´æ–°åˆ†ç»„çš„éŸ³é¢‘æ•°é‡
      await this.updateGroupAudioCount(groupId);
    }
  }

  /**
   * æ ¹æ®åˆ†ç»„IDæŸ¥è¯¢éŸ³é¢‘è®°å½•ï¼ˆæ”¯æŒå¤šåˆ†ç»„ï¼‰
   */
  public async queryAudioRecordsByGroup(groupId: number): Promise<AudioRecord[]> {
    const records = await this.getAllRecords();
    
    // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šæ£€æŸ¥groupIdsæ•°ç»„æ˜¯å¦åŒ…å«è¯¥åˆ†ç»„ID
    const filteredRecords = records.filter(record => {
      // ä¼˜å…ˆä½¿ç”¨æ–°ç‰ˆæœ¬çš„groupIds
      if (record.groupIds) {
        return record.groupIds.includes(groupId);
      }
      // å…¼å®¹æ—§ç‰ˆæœ¬çš„groupId
      return record.groupId === groupId;
    });
    
    return filteredRecords.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
  }

  /**
   * æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡ï¼ˆæ”¯æŒå¤šåˆ†ç»„ï¼‰
   */
  private async updateGroupAudioCount(groupId: number): Promise<void> {
    if (!this.dataPreferences) return;

    const records = await this.getAllRecords();
    
    // ğŸ”¥ å¤šåˆ†ç»„æ”¯æŒï¼šç»Ÿè®¡groupIdsä¸­åŒ…å«è¯¥åˆ†ç»„IDçš„è®°å½•æ•°
    const count = records.filter(record => {
      if (record.groupIds) {
        return record.groupIds.includes(groupId);
      }
      // å…¼å®¹æ—§ç‰ˆæœ¬
      return record.groupId === groupId;
    }).length;
    
    const groups = await this.getAllGroups();
    const group = groups.find(g => g.id === groupId);
    
    if (group) {
      group.audioCount = count;
      await this.saveGroups(groups);
    }
  }

  /**
   * å…³é—­æ•°æ®åº“
   */
  public async closeDatabase(): Promise<void> {
    // preferencesä¸éœ€è¦æ˜¾å¼å…³é—­
    this.dataPreferences = null;
  }
}