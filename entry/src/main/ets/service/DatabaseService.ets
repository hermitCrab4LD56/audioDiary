import { preferences } from '@kit.ArkData';
import { AudioRecord, AudioGroup } from '../model/DataModel';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { common } from '@kit.AbilityKit';

const TAG = 'DatabaseService';
const DOMAIN = 0x0000;

/**
 * éŸ³é¢‘è®°å½•è¾“å…¥æ¥å£ï¼ˆä¸åŒ…å«idå­—æ®µï¼‰
 */
export interface AudioRecordInput {
  fileName: string;
  filePath: string;
  duration: number;
  fileSize: number;
  createTime: number;
  isTop: boolean;
  groupId?: number;
}

/**
 * æ•°æ®åº“æœåŠ¡ç±»
 * è´Ÿè´£éŸ³é¢‘è®°å½•å’Œåˆ†ç»„çš„æ•°æ®åº“æ“ä½œ
 * ä½¿ç”¨preferenceså­˜å‚¨æ›¿ä»£relationalStore
 */
export class DatabaseService {
  private static instance: DatabaseService;
  private dataPreferences: preferences.Preferences | null = null;
  private readonly PREF_NAME = 'AudioDiaryData';
  private readonly RECORDS_KEY = 'audio_records';
  private readonly GROUPS_KEY = 'audio_groups';
  private readonly NEXT_RECORD_ID_KEY = 'next_record_id';
  private readonly NEXT_GROUP_ID_KEY = 'next_group_id';

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  public async initDatabase(context: Context | common.UIAbilityContext): Promise<void> {
    try {
      this.dataPreferences = await preferences.getPreferences(context, this.PREF_NAME);
      await this.initDefaultData();
      hilog.info(DOMAIN, TAG, 'Database initialized successfully');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to initialize database: ${JSON.stringify(error)}`);
      throw new Error(`Failed to initialize database: ${JSON.stringify(error)}`);
    }
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤æ•°æ®
   */
  private async initDefaultData(): Promise<void> {
    if (!this.dataPreferences) return;

    // åˆå§‹åŒ–åˆ†ç»„æ•°æ® - ä¸åˆ›å»ºé»˜è®¤åˆ†ç»„ï¼Œè®©ç”¨æˆ·è‡ªå·±åˆ›å»º
    const groups = await this.getAllGroups();
    if (groups.length === 0) {
      await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify([]));
      await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, 1);
    }

    // åˆå§‹åŒ–è®°å½•æ•°æ®
    const records = await this.getAllRecords();
    if (records.length === 0) {
      await this.dataPreferences.put(this.RECORDS_KEY, JSON.stringify([]));
      await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, 1);
    }

    await this.dataPreferences.flush();
  }

  /**
   * è·å–æ‰€æœ‰è®°å½•
   */
  private async getAllRecords(): Promise<AudioRecord[]> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ” getAllRecords() å¼€å§‹ä»æ•°æ®åº“è¯»å–è®°å½•`);
    
    if (!this.dataPreferences) {
      hilog.warn(DOMAIN, TAG, `[${timestamp}] âš ï¸ dataPreferencesæœªåˆå§‹åŒ–ï¼Œè¿”å›ç©ºæ•°ç»„`);
      return [];
    }
    
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ è°ƒç”¨dataPreferences.get()è¯»å–è®°å½•æ•°æ®`);
    const recordsStr = await this.dataPreferences.get(this.RECORDS_KEY, '[]') as string;
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š ä»å­˜å‚¨ä¸­è·å–åˆ°çš„åŸå§‹æ•°æ®é•¿åº¦: ${recordsStr.length}å­—ç¬¦`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ åŸå§‹æ•°æ®å†…å®¹é¢„è§ˆ: ${recordsStr.substring(0, 200)}${recordsStr.length > 200 ? '...' : ''}`);
    
    try {
      const records = JSON.parse(recordsStr) as AudioRecord[];
      hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… JSONè§£ææˆåŠŸï¼Œè·å–åˆ° ${records.length} æ¡è®°å½•`);
      
      if (records.length > 0) {
        hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“‹ è®°å½•è¯¦æƒ…é¢„è§ˆ:`);
        records.slice(0, 2).forEach((record, index) => {
          hilog.info(DOMAIN, TAG, `[${timestamp}]   è®°å½•${index + 1}: ID=${record.id}, æ–‡ä»¶å='${record.fileName}', æ—¶é•¿=${record.duration}ms`);
        });
      }
      
      return records;
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] âŒ JSONè§£æå¤±è´¥: ${JSON.stringify(error)}`);
      hilog.error(DOMAIN, TAG, `[${timestamp}] åŸå§‹æ•°æ®: ${recordsStr}`);
      return [];
    }
  }

  /**
   * è·å–æ‰€æœ‰åˆ†ç»„
   */
  public async getAllGroups(): Promise<AudioGroup[]> {
    if (!this.dataPreferences) return [];
    
    const groupsStr = await this.dataPreferences.get(this.GROUPS_KEY, '[]') as string;
    return JSON.parse(groupsStr) as AudioGroup[];
  }

  /**
   * ä¿å­˜è®°å½•
   */
  private async saveRecords(records: AudioRecord[]): Promise<void> {
    if (!this.dataPreferences) return;
    
    await this.dataPreferences.put(this.RECORDS_KEY, JSON.stringify(records));
    await this.dataPreferences.flush();
  }

  /**
   * ä¿å­˜åˆ†ç»„
   */
  private async saveGroups(groups: AudioGroup[]): Promise<void> {
    if (!this.dataPreferences) return;
    
    await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify(groups));
    await this.dataPreferences.flush();
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªè®°å½•ID
   */
  private async getNextRecordId(): Promise<number> {
    if (!this.dataPreferences) return 1;
    
    const nextId = await this.dataPreferences.get(this.NEXT_RECORD_ID_KEY, 1) as number;
    await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, nextId + 1);
    await this.dataPreferences.flush();
    return nextId;
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªåˆ†ç»„ID
   */
  private async getNextGroupId(): Promise<number> {
    if (!this.dataPreferences) return 1;
    
    const nextId = await this.dataPreferences.get(this.NEXT_GROUP_ID_KEY, 1) as number;
    await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, nextId + 1);
    await this.dataPreferences.flush();
    return nextId;
  }

  // ==================== éŸ³é¢‘è®°å½•æ“ä½œ ====================

  /**
   * æ’å…¥éŸ³é¢‘è®°å½•
   */
  public async insertAudioRecord(record: AudioRecordInput): Promise<number> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] insertAudioRecord() started, params: ${JSON.stringify(record)}`);
    
    if (!this.dataPreferences) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] Database not initialized`);
      throw new Error('Database not initialized');
    }
    hilog.info(DOMAIN, TAG, `[${timestamp}] Database initialized, starting to get all records`);

    const records = await this.getAllRecords();
    hilog.info(DOMAIN, TAG, `[${timestamp}] Got ${records.length} existing records`);
    
    const newId = await this.getNextRecordId();
    hilog.info(DOMAIN, TAG, `[${timestamp}] Generated new record ID: ${newId}`);
    
    const newRecord: AudioRecord = {
      id: newId,
      fileName: record.fileName,
      filePath: record.filePath,
      duration: record.duration,
      fileSize: record.fileSize,
      createTime: record.createTime,
      isTop: record.isTop,
      groupId: record.groupId || 0 // 0è¡¨ç¤ºæœªåˆ†ç»„
    };
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ’¾ æ•°æ®åº“ä¿å­˜ - åˆ›å»ºæ–°è®°å½•å¯¹è±¡:`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ è®°å½•ID: ${newRecord.id}`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æ–‡ä»¶å: '${newRecord.fileName}'`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æ–‡ä»¶è·¯å¾„: '${newRecord.filePath}'`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æ—¶é•¿: ${newRecord.duration}ms`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æ–‡ä»¶å¤§å°: ${newRecord.fileSize} bytes`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ åˆ›å»ºæ—¶é—´: ${new Date(newRecord.createTime).toLocaleString()}`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ åˆ†ç»„ID: ${newRecord.groupId}`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ å®Œæ•´è®°å½•å¯¹è±¡: ${JSON.stringify(newRecord)}`);

    records.push(newRecord);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Added new record to list, current total: ${records.length}`);
    
    await this.saveRecords(records);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Record saved successfully`);
    
    // æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡
    if (newRecord.groupId) {
      hilog.info(DOMAIN, TAG, `[${timestamp}] Starting to update audio count for group ${newRecord.groupId}`);
      await this.updateGroupAudioCount(newRecord.groupId);
      hilog.info(DOMAIN, TAG, `[${timestamp}] Group audio count update completed`);
    }

    hilog.info(DOMAIN, TAG, `[${timestamp}] insertAudioRecord() executed successfully, returning ID: ${newId}`);
    return newId;
  }

  /**
   * æŸ¥è¯¢æ‰€æœ‰éŸ³é¢‘è®°å½•
   */
  public async queryAllAudioRecords(): Promise<AudioRecord[]> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ” queryAllAudioRecords() å¼€å§‹æŸ¥è¯¢æ‰€æœ‰éŸ³é¢‘è®°å½•`);
    
    const records = await this.getAllRecords();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“Š ä»æ•°æ®åº“è·å–åˆ° ${records.length} æ¡éŸ³é¢‘è®°å½•`);
    
    if (records.length > 0) {
      hilog.info(DOMAIN, TAG, `[${timestamp}] ğŸ“ æœ€æ–°çš„3æ¡è®°å½•è¯¦æƒ…:`);
      records.slice(0, 3).forEach((record, index) => {
        hilog.info(DOMAIN, TAG, `[${timestamp}] è®°å½•${index + 1}: ID=${record.id}, æ–‡ä»¶å='${record.fileName}', åˆ›å»ºæ—¶é—´=${new Date(record.createTime).toLocaleString()}`);
      });
    } else {
      hilog.warn(DOMAIN, TAG, `[${timestamp}] âš ï¸ æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•éŸ³é¢‘è®°å½•`);
    }
    
    const sortedRecords = records.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
    
    hilog.info(DOMAIN, TAG, `[${timestamp}] âœ… éŸ³é¢‘è®°å½•æ’åºå®Œæˆï¼Œè¿”å› ${sortedRecords.length} æ¡è®°å½•`);
    return sortedRecords;
  }

  /**
   * æ ¹æ®å…³é”®è¯æœç´¢éŸ³é¢‘è®°å½•
   */
  public async searchAudioRecords(keyword: string): Promise<AudioRecord[]> {
    const records = await this.getAllRecords();
    const filteredRecords = records.filter(record => 
      record.fileName.toLowerCase().includes(keyword.toLowerCase())
    );
    
    return filteredRecords.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
  }

  /**
   * æ›´æ–°éŸ³é¢‘è®°å½•
   */
  public async updateAudioRecord(record: AudioRecord): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const index = records.findIndex(r => r.id === record.id);
    
    if (index !== -1) {
      records[index] = record;
      await this.saveRecords(records);
    }
  }

  /**
   * åˆ é™¤éŸ³é¢‘è®°å½•
   */
  public async deleteAudioRecord(id: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const recordIndex = records.findIndex(r => r.id === id);
    
    if (recordIndex !== -1) {
      const record = records[recordIndex];
      records.splice(recordIndex, 1);
      await this.saveRecords(records);
      
      // æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡
      if (record.groupId) {
        await this.updateGroupAudioCount(record.groupId);
      }
    }
  }

  /**
   * åˆ‡æ¢ç½®é¡¶çŠ¶æ€
   */
  public async toggleTopStatus(id: number, isTop: boolean): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const record = records.find(r => r.id === id);
    
    if (record) {
      record.isTop = isTop;
      await this.saveRecords(records);
    }
  }

  /**
   * æ ¹æ®IDè·å–éŸ³é¢‘è®°å½•
   */
  public async getAudioRecordById(id: number): Promise<AudioRecord | null> {
    const records = await this.getAllRecords();
    return records.find(r => r.id === id) || null;
  }

  /**
   * æ¸…ç†æŸåçš„æ•°æ®ï¼ˆä¿®å¤é‡å¤è®°å½•å’Œé”™è¯¯åˆ†ç»„ï¼‰
   */
  public async cleanupCorruptedData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    hilog.info(DOMAIN, TAG, 'Starting data cleanup...');
    
    // é¦–å…ˆæ¸…ç†æ¨¡æ‹Ÿæ•°æ®
    await this.cleanupMockData();
    
    // æ¸…ç†é‡å¤çš„éŸ³é¢‘è®°å½•
    const records = await this.getAllRecords();
    const uniqueRecords = new Map<string, AudioRecord>();
    
    // ä½¿ç”¨æ–‡ä»¶è·¯å¾„ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œä¿ç•™æœ€æ–°çš„è®°å½•
    records.forEach(record => {
      const key = record.filePath;
      if (!uniqueRecords.has(key) || record.createTime > uniqueRecords.get(key)!.createTime) {
        uniqueRecords.set(key, record);
      }
    });
    
    const cleanedRecords = Array.from(uniqueRecords.values());
    hilog.info(DOMAIN, TAG, `Removed ${records.length - cleanedRecords.length} duplicate records`);
    
    // æ¸…ç†æ— æ•ˆçš„åˆ†ç»„ï¼ˆåªä¿ç•™æœ‰éŸ³é¢‘è®°å½•çš„åˆ†ç»„ï¼‰
    const groups = await this.getAllGroups();
    const validGroupIds = new Set(cleanedRecords.map(r => r.groupId).filter(id => id && id > 0));
    const cleanedGroups = groups.filter(group => validGroupIds.has(group.id));
    
    hilog.info(DOMAIN, TAG, `Removed ${groups.length - cleanedGroups.length} invalid groups`);
    
    // ä¿å­˜æ¸…ç†åçš„æ•°æ®
    await this.saveRecords(cleanedRecords);
    await this.saveGroups(cleanedGroups);
    
    // é‡æ–°è®¡ç®—åˆ†ç»„éŸ³é¢‘æ•°é‡
    for (const group of cleanedGroups) {
      await this.updateGroupAudioCount(group.id);
    }
    
    hilog.info(DOMAIN, TAG, 'Data cleanup completed successfully');
  }

  /**
   * æ¸…ç†æ¨¡æ‹Ÿæ•°æ®
   * åˆ é™¤åŒ…å«æ¨¡æ‹Ÿã€æµ‹è¯•ã€ç¤ºä¾‹ç­‰å…³é”®è¯çš„éŸ³é¢‘è®°å½•
   */
  public async cleanupMockData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    hilog.info(DOMAIN, TAG, 'Starting mock data cleanup...');
    
    const records = await this.getAllRecords();
    const mockKeywords = ['mock', 'test', 'sample', 'æ¨¡æ‹Ÿ', 'æµ‹è¯•', 'ç¤ºä¾‹', 'æ¼”ç¤º'];
    
    // è¿‡æ»¤æ‰åŒ…å«æ¨¡æ‹Ÿå…³é”®è¯çš„è®°å½•
    const realRecords = records.filter(record => {
      const fileName = record.fileName.toLowerCase();
      const filePath = record.filePath.toLowerCase();
      
      // æ£€æŸ¥æ–‡ä»¶åå’Œè·¯å¾„æ˜¯å¦åŒ…å«æ¨¡æ‹Ÿå…³é”®è¯
      return !mockKeywords.some(keyword => 
        fileName.includes(keyword) || filePath.includes(keyword)
      );
    });
    
    const removedCount = records.length - realRecords.length;
    if (removedCount > 0) {
      await this.saveRecords(realRecords);
      hilog.info(DOMAIN, TAG, `Removed ${removedCount} mock data records`);
    } else {
      hilog.info(DOMAIN, TAG, 'No mock data found to clean');
    }
  }

  /**
   * æ¸…ç†æ‰€æœ‰æ•°æ®ï¼ˆç”¨äºè°ƒè¯•å’Œé‡ç½®ï¼‰
   */
  public async clearAllData(): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    // æ¸…ç©ºæ‰€æœ‰è®°å½•å’Œåˆ†ç»„
    await this.dataPreferences.put(this.RECORDS_KEY, JSON.stringify([]));
    await this.dataPreferences.put(this.GROUPS_KEY, JSON.stringify([]));
    
    // é‡ç½®IDè®¡æ•°å™¨
    await this.dataPreferences.put(this.NEXT_RECORD_ID_KEY, 1);
    await this.dataPreferences.put(this.NEXT_GROUP_ID_KEY, 1);
    
    await this.dataPreferences.flush();
    hilog.info(DOMAIN, TAG, 'All data cleared successfully');
  }

  // ==================== éŸ³é¢‘åˆ†ç»„æ“ä½œ ====================

  /**
   * åˆ›å»ºåˆ†ç»„
   */
  public async createGroup(groupName: string): Promise<number> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const groups = await this.getAllGroups();
    const newId = await this.getNextGroupId();
    
    const newGroup: AudioGroup = {
      id: newId,
      groupName: groupName,
      createTime: Date.now(),
      audioCount: 0
    };

    groups.push(newGroup);
    await this.saveGroups(groups);
    
    return newId;
  }

  /**
   * æŸ¥è¯¢æ‰€æœ‰åˆ†ç»„
   */
  public async queryAllGroups(): Promise<AudioGroup[]> {
    const groups = await this.getAllGroups();
    return groups.sort((a, b) => b.createTime - a.createTime);
  }

  /**
   * æ›´æ–°åˆ†ç»„åç§°
   */
  public async updateGroupName(id: number, newName: string): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const groups = await this.getAllGroups();
    const group = groups.find(g => g.id === id);
    
    if (group) {
      group.groupName = newName;
      await this.saveGroups(groups);
    }
  }

  /**
   * åˆ é™¤åˆ†ç»„
   */
  public async deleteGroup(id: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    // å°†è¯¥åˆ†ç»„ä¸‹çš„éŸ³é¢‘ç§»åˆ°æœªåˆ†ç»„çŠ¶æ€
    const records = await this.getAllRecords();
    records.forEach(record => {
      if (record.groupId === id) {
        record.groupId = 0; // 0è¡¨ç¤ºæœªåˆ†ç»„
      }
    });
    await this.saveRecords(records);

    // åˆ é™¤åˆ†ç»„
    const groups = await this.getAllGroups();
    const groupIndex = groups.findIndex(g => g.id === id);
    if (groupIndex !== -1) {
      groups.splice(groupIndex, 1);
      await this.saveGroups(groups);
    }
  }

  /**
   * æ·»åŠ éŸ³é¢‘åˆ°åˆ†ç»„
   */
  public async addAudioToGroup(audioId: number, groupId: number): Promise<void> {
    if (!this.dataPreferences) {
      throw new Error('Database not initialized');
    }

    const records = await this.getAllRecords();
    const record = records.find(r => r.id === audioId);
    
    if (record) {
      const oldGroupId = record.groupId;
      record.groupId = groupId;
      await this.saveRecords(records);
      
      // æ›´æ–°ç›¸å…³åˆ†ç»„çš„éŸ³é¢‘æ•°é‡
      if (oldGroupId) {
        await this.updateGroupAudioCount(oldGroupId);
      }
      await this.updateGroupAudioCount(groupId);
    }
  }

  /**
   * ä»åˆ†ç»„ç§»é™¤éŸ³é¢‘ï¼ˆç§»åˆ°æœªåˆ†ç»„çŠ¶æ€ï¼‰
   */
  public async removeAudioFromGroup(audioId: number): Promise<void> {
    await this.addAudioToGroup(audioId, 0);
  }

  /**
   * æ ¹æ®åˆ†ç»„IDæŸ¥è¯¢éŸ³é¢‘è®°å½•
   */
  public async queryAudioRecordsByGroup(groupId: number): Promise<AudioRecord[]> {
    const records = await this.getAllRecords();
    const filteredRecords = records.filter(record => record.groupId === groupId);
    
    return filteredRecords.sort((a, b) => {
      if (a.isTop !== b.isTop) {
        return b.isTop ? 1 : -1;
      }
      return b.createTime - a.createTime;
    });
  }

  /**
   * æ›´æ–°åˆ†ç»„éŸ³é¢‘æ•°é‡
   */
  private async updateGroupAudioCount(groupId: number): Promise<void> {
    if (!this.dataPreferences) return;

    const records = await this.getAllRecords();
    const count = records.filter(record => record.groupId === groupId).length;
    
    const groups = await this.getAllGroups();
    const group = groups.find(g => g.id === groupId);
    
    if (group) {
      group.audioCount = count;
      await this.saveGroups(groups);
    }
  }

  /**
   * å…³é—­æ•°æ®åº“
   */
  public async closeDatabase(): Promise<void> {
    // preferencesä¸éœ€è¦æ˜¾å¼å…³é—­
    this.dataPreferences = null;
  }
}