import { media } from '@kit.MediaKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { fileIo } from '@kit.CoreFileKit';
import { RecordState, AudioConfig, RecorderAudioConfig, RecordResult } from '../model/DataModel';
import { common } from '@kit.AbilityKit';
import { abilityAccessCtrl, bundleManager, Permissions } from '@kit.AbilityKit';
import { DevConfig, DevUtils } from '../config/DevConfig';

const TAG = 'AudioRecorderService';
const DOMAIN = 0x0000;

/**
 * æ¨¡æ‹Ÿå½•éŸ³å™¨æ¥å£
 */
interface MockRecorder {
  prepare(config: media.AVRecorderConfig): Promise<void>;
  start(): Promise<void>;
  pause(): Promise<void>;
  resume(): Promise<void>;
  stop(): Promise<void>;
  release(): Promise<void>;
  on(event: string, callback: (data?: Object) => void): void;
}

/**
 * æ¨¡æ‹Ÿå½•éŸ³å™¨å®ç°ç±»
 */
class MockRecorderImpl implements MockRecorder {
  private service: AudioRecorderService;

  constructor(service: AudioRecorderService) {
    this.service = service;
  }

  async prepare(config: media.AVRecorderConfig): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šå‡†å¤‡å½•éŸ³');
    await DevUtils.mockDelay(100);
    this.service.setMockRecorderState("prepared");
    this.service.handleMockStateChange("prepared" as media.AVRecorderState);
  }

  async start(): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šå¼€å§‹å½•éŸ³');
    await DevUtils.mockDelay(50);
    this.service.setMockRecorderState("started");
    this.service.handleMockStateChange("started" as media.AVRecorderState);
  }

  async pause(): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šæš‚åœå½•éŸ³');
    await DevUtils.mockDelay(50);
    this.service.setMockRecorderState("paused");
    this.service.handleMockStateChange("paused" as media.AVRecorderState);
  }

  async resume(): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šæ¢å¤å½•éŸ³');
    await DevUtils.mockDelay(50);
    this.service.setMockRecorderState("started");
    this.service.handleMockStateChange("started" as media.AVRecorderState);
  }

  async stop(): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šåœæ­¢å½•éŸ³');
    await DevUtils.mockDelay(100);
    this.service.setMockRecorderState("stopped");
    this.service.handleMockStateChange("stopped" as media.AVRecorderState);
    // åœ¨å¼€å‘æ¨¡å¼ä¸‹åˆ›å»ºæ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶
    await this.service.createMockAudioFile();
  }

  async release(): Promise<void> {
    DevUtils.devLog(TAG, 'æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šé‡Šæ”¾èµ„æº');
    await DevUtils.mockDelay(50);
    this.service.setMockRecorderState("idle");
    this.service.setIsMockRecorder(false);
  }

  on(event: string, callback: (data?: Object) => void): void {
    // æ¨¡æ‹Ÿäº‹ä»¶ç›‘å¬å™¨ï¼Œå®é™…ä¸éœ€è¦åšä»»ä½•äº‹æƒ…
    DevUtils.devLog(TAG, `æ¨¡æ‹Ÿå½•éŸ³å™¨ï¼šæ³¨å†Œäº‹ä»¶ç›‘å¬å™¨ ${event}`);
  }
}

/**
 * éŸ³é¢‘å½•åˆ¶æœåŠ¡ç±»
 * è´Ÿè´£éŸ³é¢‘å½•åˆ¶åŠŸèƒ½çš„ç®¡ç†
 */
export class AudioRecorderService {
  private static instance: AudioRecorderService;
  private audioRecorder: media.AVRecorder | MockRecorder | null = null;
  private recordState: RecordState = RecordState.IDLE;
  private recordStartTime: number = 0;
  private recordDuration: number = 0;
  private currentFilePath: string = '';
  private context: common.UIAbilityContext | null = null;
  
  // å½•åˆ¶çŠ¶æ€ç›‘å¬å™¨
  private stateChangeListeners: Array<(state: RecordState) => void> = [];
  private durationUpdateListeners: Array<(duration: number) => void> = [];
  private amplitudeListeners: ((amplitude: number) => void)[] = [];
  private errorListeners: ((error: BusinessError) => void)[] = [];
  
  // æŒ¯å¹…æ£€æµ‹ç›¸å…³
  private amplitudeTimer: number | null = null;
  private lastAmplitudeTime: number = 0;
  
  // æ—¶é•¿è®¡æ—¶å™¨ç›¸å…³
  private durationTimer: number | null = null;
  
  // å¼€å‘æ¨¡å¼ç›¸å…³
  private isMockRecorder: boolean = false;
  private mockRecorderState: string = "idle";

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): AudioRecorderService {
    if (!AudioRecorderService.instance) {
      AudioRecorderService.instance = new AudioRecorderService();
    }
    return AudioRecorderService.instance;
  }

  /**
   * åˆå§‹åŒ–å½•éŸ³æœåŠ¡
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   */
  async initialize(context: common.UIAbilityContext): Promise<void> {
    this.context = context;
    const maxRetries = 5; // å¢åŠ é‡è¯•æ¬¡æ•°
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        hilog.info(DOMAIN, TAG, `Initializing AudioRecorderService (attempt ${attempt}/${maxRetries})`);

        // æ˜¾ç¤ºå½“å‰è¿è¡Œæ¨¡å¼
        if (DevConfig.isDevMode()) {
          DevUtils.devWarning(TAG, 'ğŸ”§ å½“å‰è¿è¡Œåœ¨å¼€å‘æ¨¡å¼ä¸‹ï¼Œå½•éŸ³åŠŸèƒ½å°†ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
          DevUtils.devLog(TAG, DevConfig.getDevModeInfo());
          hilog.warn(DOMAIN, TAG, 'Running in DEVELOPMENT mode - using mock recording functionality');
        } else {
          hilog.info(DOMAIN, TAG, 'Running in PRODUCTION mode - using real recording functionality');
        }

        // é‡ç½®çŠ¶æ€
        this.recordState = RecordState.IDLE;
        
        // æ£€æŸ¥æƒé™ï¼ˆåŒ…å«åŠ¨æ€è¯·æ±‚ï¼‰
        await this.checkRecordPermissions();
        hilog.info(DOMAIN, TAG, 'Permissions checked successfully');

        // åˆ›å»ºå½•éŸ³å™¨
        await this.createRecorder();
        hilog.info(DOMAIN, TAG, 'Recorder created successfully');
        
        // éªŒè¯å½•éŸ³å™¨çŠ¶æ€
        if (!this.audioRecorder) {
          throw new Error("Recorder creation failed - recorder is null");
        }

        hilog.info(DOMAIN, TAG, 'AudioRecorderService initialized successfully');
        return;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        hilog.error(DOMAIN, TAG, `Initialization attempt ${attempt} failed: ${lastError.message}`);

        // å®Œå…¨æ¸…ç†çŠ¶æ€
        await this.cleanup();
        
        // å¦‚æœæ˜¯æƒé™é”™è¯¯ï¼Œä¸éœ€è¦é‡è¯•å¤ªå¤šæ¬¡
        if (lastError.message.includes("permission") || lastError.message.includes("æƒé™")) {
          if (attempt >= 2) {
            hilog.error(DOMAIN, TAG, 'Permission error persists, stopping retries');
            break;
          }
        }

        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < maxRetries) {
          const delay = Math.min(attempt * 500, 2000); // é€’å¢å»¶è¿Ÿï¼Œæœ€å¤§2ç§’
          hilog.info(DOMAIN, TAG, `Waiting ${delay}ms before retry...`);
          await new Promise<void>(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    const errorMessage = `Failed to initialize AudioRecorderService after ${maxRetries} attempts. Last error: ${lastError?.message || 'Unknown error'}`;
    hilog.error(DOMAIN, TAG, errorMessage);
    throw new Error(errorMessage);
  }
  
  /**
   * æ¸…ç†å½•éŸ³å™¨èµ„æºå’ŒçŠ¶æ€
   */
  private async cleanup(): Promise<void> {
    try {
      if (this.audioRecorder) {
        // å°è¯•åœæ­¢å½•éŸ³
        if (this.recordState === RecordState.RECORDING || this.recordState === RecordState.PAUSED) {
          try {
            await this.audioRecorder.stop();
          } catch (stopError) {
            hilog.warn(DOMAIN, TAG, `Failed to stop recorder during cleanup: ${stopError}`);
          }
        }
        
        // é‡Šæ”¾å½•éŸ³å™¨
        try {
          await this.audioRecorder.release();
        } catch (releaseError) {
          hilog.warn(DOMAIN, TAG, `Failed to release recorder during cleanup: ${releaseError}`);
        }
        
        this.audioRecorder = null;
      }
      
      // é‡ç½®çŠ¶æ€å¹¶é€šçŸ¥
      this.recordState = RecordState.IDLE;
      this.notifyStateChange(this.recordState);
      this.recordStartTime = 0;
      this.recordDuration = 0;
      this.currentFilePath = "";
      
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Error during cleanup: ${error}`);
    }
  }

  /**
   * æ£€æŸ¥å½•éŸ³æƒé™
   */
  private async checkRecordPermissions(): Promise<void> {
    // å¼€å‘æ¨¡å¼ä¸‹ç»•è¿‡æƒé™æ£€æŸ¥
    if (DevConfig.isDevMode()) {
      DevUtils.devLog(TAG, 'å¼€å‘æ¨¡å¼ï¼šç»•è¿‡æƒé™æ£€æŸ¥ï¼Œç›´æ¥è¿”å›æƒé™å·²æˆäºˆ');
      hilog.info(DOMAIN, TAG, 'Dev mode: Bypassing permission check - permissions granted');
      return;
    }

    if (!this.context) {
      throw new Error("Context not initialized");
    }

    try {
      const atManager = abilityAccessCtrl.createAtManager();
      const bundleInfo = await bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
      const tokenId = bundleInfo.appInfo.accessTokenId;

      // æ£€æŸ¥éº¦å…‹é£æƒé™
      const microphonePermission: Permissions = "ohos.permission.MICROPHONE";
      let micResult = await atManager.checkAccessToken(tokenId, microphonePermission);
      
      if (micResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        hilog.warn(DOMAIN, TAG, 'Microphone permission not granted, requesting permission');
        // è¯·æ±‚éº¦å…‹é£æƒé™
        try {
          await atManager.requestPermissionsFromUser(this.context, [microphonePermission]);
          // é‡æ–°æ£€æŸ¥æƒé™
          micResult = await atManager.checkAccessToken(tokenId, microphonePermission);
          if (micResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
            throw new Error("ç”¨æˆ·æ‹’ç»äº†éº¦å…‹é£æƒé™ï¼Œæ— æ³•è¿›è¡Œå½•éŸ³");
          }
        } catch (requestError) {
          hilog.error(DOMAIN, TAG, `Failed to request microphone permission: ${JSON.stringify(requestError)}`);
          throw new Error("è¯·æ±‚éº¦å…‹é£æƒé™å¤±è´¥ï¼Œè¯·åœ¨è®¾ç½®ä¸­æ‰‹åŠ¨å¼€å¯æƒé™");
        }
      }

      // æ£€æŸ¥éŸ³é¢‘å†™å…¥æƒé™
      const writeAudioPermission: Permissions = "ohos.permission.WRITE_AUDIO";
      let writeResult = await atManager.checkAccessToken(tokenId, writeAudioPermission);
      
      if (writeResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        hilog.warn(DOMAIN, TAG, 'Write audio permission not granted, requesting permission');
        // è¯·æ±‚éŸ³é¢‘å†™å…¥æƒé™
        try {
          await atManager.requestPermissionsFromUser(this.context, [writeAudioPermission]);
          // é‡æ–°æ£€æŸ¥æƒé™
          writeResult = await atManager.checkAccessToken(tokenId, writeAudioPermission);
          if (writeResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
            throw new Error("ç”¨æˆ·æ‹’ç»äº†éŸ³é¢‘å†™å…¥æƒé™ï¼Œæ— æ³•ä¿å­˜å½•éŸ³æ–‡ä»¶");
          }
        } catch (requestError) {
          hilog.error(DOMAIN, TAG, `Failed to request write audio permission: ${JSON.stringify(requestError)}`);
          throw new Error("è¯·æ±‚éŸ³é¢‘å†™å…¥æƒé™å¤±è´¥ï¼Œè¯·åœ¨è®¾ç½®ä¸­æ‰‹åŠ¨å¼€å¯æƒé™");
        }
      }

      hilog.info(DOMAIN, TAG, 'All recording permissions granted successfully');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Permission check failed: ${JSON.stringify(error)}`);
      throw new Error(error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * åˆ›å»ºå½•åˆ¶å™¨
   */
  private async createRecorder(): Promise<void> {
    try {
      // å¦‚æœå·²å­˜åœ¨å½•éŸ³å™¨ï¼Œå…ˆé‡Šæ”¾
      if (this.audioRecorder) {
        hilog.info(DOMAIN, TAG, 'Releasing existing recorder before creating new one');
        try {
          if (DevConfig.isProdMode()) {
            await this.audioRecorder.release();
          }
        } catch (releaseError) {
          hilog.warn(DOMAIN, TAG, `Failed to release existing recorder: ${JSON.stringify(releaseError)}`);
        }
        this.audioRecorder = null;
      }
      
      // å¼€å‘æ¨¡å¼ä¸‹åˆ›å»ºæ¨¡æ‹Ÿå½•éŸ³å™¨
      if (DevConfig.isDevMode()) {
        DevUtils.devLog(TAG, 'å¼€å‘æ¨¡å¼ï¼šåˆ›å»ºæ¨¡æ‹Ÿå½•éŸ³å™¨');
        hilog.info(DOMAIN, TAG, 'Dev mode: Creating mock recorder');
        this.audioRecorder = this.createMockRecorder();
        hilog.info(DOMAIN, TAG, 'Mock recorder created successfully');
        return;
      }
      
      hilog.info(DOMAIN, TAG, 'Creating new AVRecorder instance...');
      this.audioRecorder = await media.createAVRecorder();
      
      if (!this.audioRecorder) {
        throw new Error("AVRecorder creation returned null");
      }
      
      hilog.info(DOMAIN, TAG, 'Setting up recorder callbacks...');
      this.setupRecorderCallbacks();
      
      hilog.info(DOMAIN, TAG, 'Recorder created and configured successfully');
    } catch (error) {
      let errorMessage = "Failed to create recorder: ";
      if (error instanceof Error) {
        errorMessage += error.message;
      } else {
        errorMessage += String(error);
      }
      hilog.error(DOMAIN, TAG, errorMessage);
      
      // æ¸…ç†çŠ¶æ€
      this.audioRecorder = null;
      this.recordState = RecordState.ERROR;
      
      throw new Error(errorMessage);
    }
  }

  /**
   * åˆ›å»ºæ¨¡æ‹Ÿå½•éŸ³å™¨
   */
  private createMockRecorder(): MockRecorder {
    this.isMockRecorder = true;
    this.mockRecorderState = 'idle';
    return new MockRecorderImpl(this);
  }
  
  /**
   * è®¾ç½®æ¨¡æ‹Ÿå½•éŸ³å™¨çŠ¶æ€
   */
  public setMockRecorderState(state: string): void {
    this.mockRecorderState = state;
  }
  
  /**
   * è®¾ç½®æ˜¯å¦ä¸ºæ¨¡æ‹Ÿå½•éŸ³å™¨
   */
  public setIsMockRecorder(isMock: boolean): void {
    this.isMockRecorder = isMock;
  }
  
  /**
   * å¤„ç†æ¨¡æ‹Ÿå½•éŸ³å™¨çŠ¶æ€å˜åŒ–
   */
  public handleMockStateChange(state: media.AVRecorderState): void {
    this.handleStateChange(state);
  }
  
  /**
   * åˆ›å»ºæ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶
   */
  public async createMockAudioFile(): Promise<void> {
    if (!this.currentFilePath || DevConfig.isProdMode()) {
      return;
    }
    
    try {
      const mockConfig = DevConfig.getMockRecordingConfig();
      const fileSize = DevConfig.generateMockFileSize(this.recordDuration);
      
      // åˆ›å»ºæ¨¡æ‹Ÿçš„éŸ³é¢‘æ–‡ä»¶å†…å®¹
      const mockContent = this.generateMockAudioContent(fileSize);
      
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      const dirPath = this.currentFilePath.substring(0, this.currentFilePath.lastIndexOf("/"));
      if (!await fileIo.access(dirPath)) {
        await fileIo.mkdir(dirPath, true);
      }
      
      // å†™å…¥æ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶
      const file = fileIo.openSync(this.currentFilePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
      fileIo.writeSync(file.fd, mockContent);
      fileIo.closeSync(file);
      
      DevUtils.devLog(TAG, `æ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶å·²åˆ›å»ºï¼š${this.currentFilePath}ï¼Œå¤§å°ï¼š${fileSize}å­—èŠ‚`);
      hilog.info(DOMAIN, TAG, `Mock audio file created: ${this.currentFilePath}, size: ${fileSize} bytes`);
    } catch (error) {
      DevUtils.devError(TAG, `åˆ›å»ºæ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶å¤±è´¥ï¼š${JSON.stringify(error)}`);
      hilog.error(DOMAIN, TAG, `Failed to create mock audio file: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ç”Ÿæˆæ¨¡æ‹ŸéŸ³é¢‘æ–‡ä»¶å†…å®¹
   */
  private generateMockAudioContent(targetSize: number): string {
    const mockConfig = DevConfig.getMockRecordingConfig();
    const baseContent = mockConfig.mockAudioContent;
    
    // æ ¹æ®ç›®æ ‡å¤§å°ç”Ÿæˆå†…å®¹
    let content = `# Mock Audio File - Generated in Dev Mode\n`;
    content += `# Duration: ${this.recordDuration}ms\n`;
    content += `# Target Size: ${targetSize} bytes\n`;
    content += `# Created: ${new Date().toISOString()}\n`;
    content += `# Base64 Audio Header: ${baseContent}\n`;
    
    // å¡«å……å†…å®¹åˆ°ç›®æ ‡å¤§å°
    const padding = "A".repeat(Math.max(0, targetSize - content.length));
    content += padding;
    
    return content;
  }

  /**
   * è®¾ç½®å½•åˆ¶å™¨å›è°ƒ
   */
  private setupRecorderCallbacks(): void {
    if (!this.audioRecorder || this.isMockRecorder) return;

    // é”™è¯¯å›è°ƒ - ä½¿ç”¨æ­£ç¡®çš„å›è°ƒç­¾å
    this.audioRecorder.on("error", (data?: Object) => {
      const error = data as BusinessError;
      hilog.error(DOMAIN, TAG, `Recorder error: ${JSON.stringify(error)}`);
      this.notifyError(error);
    });
  }

  /**
   * å¤„ç†çŠ¶æ€å˜åŒ–
   */
  private handleStateChange(state: media.AVRecorderState): void {
    switch (state) {
      case "idle":
        this.recordState = RecordState.IDLE;
        break;
      case "prepared":
        this.recordState = RecordState.PREPARED;
        break;
      case "started":
        this.recordState = RecordState.RECORDING;
        this.startDurationTimer();
        this.startAmplitudeDetection();
        break;
      case "paused":
        this.recordState = RecordState.PAUSED;
        this.stopDurationTimer();
        this.stopAmplitudeDetection();
        break;
      case "stopped":
        this.recordState = RecordState.STOPPED;
        this.stopDurationTimer();
        this.stopAmplitudeDetection();
        break;
      case "error":
        this.recordState = RecordState.ERROR;
        this.stopDurationTimer();
        this.stopAmplitudeDetection();
        break;
      default:
        break;
    }
    this.notifyStateChange(this.recordState);
  }

  /**
   * å¼€å§‹å½•åˆ¶
   */
  public async startRecording(): Promise<void> {
    const currentState = this.recordState;
    hilog.info(DOMAIN, TAG, `Starting recording, current state: ${currentState}`);
    
    // æ£€æŸ¥å½•éŸ³å™¨æ˜¯å¦å·²åˆå§‹åŒ–
    if (!this.audioRecorder) {
      const errorMessage = "Recorder not initialized. Please call initialize() first.";
      hilog.error(DOMAIN, TAG, errorMessage);
      this.recordState = RecordState.ERROR;
      throw new Error(errorMessage);
    }

    // æ£€æŸ¥å½“å‰çŠ¶æ€
    if (this.recordState !== RecordState.IDLE) {
      const expectedState = RecordState.IDLE;
      const currentState = this.recordState;
      const errorMessage = `Cannot start recording in current state: ${currentState}. Expected state: ${expectedState}`;
      hilog.error(DOMAIN, TAG, errorMessage);
      throw new Error(errorMessage);
    }

    try {
      // æ˜¾ç¤ºå½•éŸ³å¼€å§‹æç¤º
      if (DevConfig.isDevMode()) {
        DevUtils.devLog(TAG, 'ğŸ¤ å¼€å§‹æ¨¡æ‹Ÿå½•éŸ³...');
      }

      hilog.info(DOMAIN, TAG, 'Preparing recorder configuration...');
      const config = await this.getRecordConfig();
      hilog.info(DOMAIN, TAG, `Record config: ${JSON.stringify(config)}`);
      
      hilog.info(DOMAIN, TAG, 'Preparing recorder...');
      await this.audioRecorder.prepare(config);
      
      hilog.info(DOMAIN, TAG, 'Starting recorder...');
      await this.audioRecorder.start();
      
      hilog.info(DOMAIN, TAG, 'Recording started successfully');
    } catch (error) {
      const errorMessage = `Failed to start recording: ${error instanceof Error ? error.message : String(error)}`;
      hilog.error(DOMAIN, TAG, errorMessage);
      
      // è®¾ç½®é”™è¯¯çŠ¶æ€
      this.recordState = RecordState.ERROR;
      this.notifyStateChange(this.recordState);
      
      // å°è¯•é‡ç½®å½•éŸ³å™¨çŠ¶æ€ï¼ˆä½¿ç”¨é‡Šæ”¾å’Œé‡æ–°åˆ›å»ºçš„æ–¹å¼æ›¿ä»£resetï¼‰
      try {
        if (this.audioRecorder) {
          await this.audioRecorder.release();
          this.audioRecorder = null;
          await this.createRecorder();
          hilog.info(DOMAIN, TAG, 'Recorder recreated after start failure');
        }
      } catch (recreateError) {
        hilog.warn(DOMAIN, TAG, `Failed to recreate recorder: ${JSON.stringify(recreateError)}`);
      }
      
      throw new Error(errorMessage);
    }
  }

  /**
   * æš‚åœå½•åˆ¶
   */
  public async pauseRecording(): Promise<void> {
    if (!this.audioRecorder) {
      throw new Error("Recorder not initialized");
    }

    try {
      await this.audioRecorder.pause();
      hilog.info(DOMAIN, TAG, 'Recording paused');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to pause recording: ${JSON.stringify(error)}`);
      throw new Error(`Failed to pause recording: ${JSON.stringify(error)}`);
    }
  }

  /**
   * æ¢å¤å½•åˆ¶
   */
  public async resumeRecording(): Promise<void> {
    if (!this.audioRecorder) {
      throw new Error("Recorder not initialized");
    }

    try {
      await this.audioRecorder.resume();
      hilog.info(DOMAIN, TAG, 'Recording resumed');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to resume recording: ${JSON.stringify(error)}`);
      throw new Error(`Failed to resume recording: ${JSON.stringify(error)}`);
    }
  }

  /**
   * åœæ­¢å½•åˆ¶
   */
  public async stopRecording(): Promise<RecordResult> {
    const timestamp = new Date().toISOString();
    hilog.info(DOMAIN, TAG, `[${timestamp}] ========== stopRecording() started ==========`);
    
    if (!this.audioRecorder) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] audioRecorder not initialized`);
      throw new Error("Recorder not initialized");
    }

    const currentState = this.recordState;
    hilog.info(DOMAIN, TAG, `[${timestamp}] Current recording state: ${currentState}`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Current file path: ${this.currentFilePath}`);
    hilog.info(DOMAIN, TAG, `[${timestamp}] Current recording duration: ${this.recordDuration}ms`);

    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåœ¨é‡æ–°åˆ›å»ºå½•éŸ³å™¨å‰å…ˆä¿å­˜è¿™äº›å€¼åˆ°å±€éƒ¨å˜é‡
    const savedFilePath = this.currentFilePath;
    const savedDuration = this.recordDuration;
    hilog.info(DOMAIN, TAG, `[${timestamp}] Saved key data - file path: '${savedFilePath}', duration: ${savedDuration}ms`);

    try {
      hilog.info(DOMAIN, TAG, `[${timestamp}] Calling audioRecorder.stop()`);
      await this.audioRecorder.stop();
      hilog.info(DOMAIN, TAG, `[${timestamp}] audioRecorder.stop() executed successfully`);
      
      // éªŒè¯ä¿å­˜çš„æ•°æ®
      if (!savedFilePath) {
        hilog.error(DOMAIN, TAG, `[${timestamp}] Saved file path is empty: '${savedFilePath}'`);
        throw new Error("Saved file path is empty");
      }
      
      if (savedDuration <= 0) {
        hilog.warn(DOMAIN, TAG, `[${timestamp}] Saved recording duration is abnormal: ${savedDuration}ms`);
      }
      
      hilog.info(DOMAIN, TAG, `[${timestamp}] Calling getFileSize() to get file size`);
      const fileSize = await this.getFileSize(savedFilePath);
      hilog.info(DOMAIN, TAG, `[${timestamp}] File size: ${fileSize} bytes`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåœ¨è·å–æ–‡ä»¶å¤§å°åå†é‡æ–°åˆ›å»ºå½•éŸ³å™¨
      hilog.info(DOMAIN, TAG, `[${timestamp}] Recreating recorder`);
      await this.createRecorder();
      hilog.info(DOMAIN, TAG, `[${timestamp}] Recorder recreated successfully`);
      
      // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ¸…ç©ºå½“å‰å½•éŸ³ç›¸å…³çŠ¶æ€ï¼Œä¸ºä¸‹æ¬¡å½•éŸ³åšå‡†å¤‡
      this.currentFilePath = "";
      this.recordDuration = 0;
      this.recordStartTime = 0;
      hilog.info(DOMAIN, TAG, `[${timestamp}] Recording state cleared, ready for next recording`);
      
      // å…ˆè®¾ç½®ä¸ºSTOPPEDçŠ¶æ€ï¼Œè®©UIçŸ¥é“å½•éŸ³å·²åœæ­¢
      this.recordState = RecordState.STOPPED;
      hilog.info(DOMAIN, TAG, `[${timestamp}] Setting recording state to STOPPED`);
      this.notifyStateChange(this.recordState);
      hilog.info(DOMAIN, TAG, `[${timestamp}] STOPPED state change notification sent`);
      
      // ç¨åè®¾ç½®ä¸ºIDLEçŠ¶æ€
      setTimeout(() => {
        this.recordState = RecordState.IDLE;
        hilog.info(DOMAIN, TAG, `[${timestamp}] Setting recording state to IDLE`);
        this.notifyStateChange(this.recordState);
        hilog.info(DOMAIN, TAG, `[${timestamp}] IDLE state change notification sent`);
      }, 100);
      
      hilog.info(DOMAIN, TAG, `[${timestamp}] Recording stop completed - file: ${savedFilePath}, duration: ${savedDuration}ms, size: ${fileSize} bytes`);
      
      const result: RecordResult = {
        filePath: savedFilePath,
        duration: savedDuration,
        fileSize
      };
      hilog.info(DOMAIN, TAG, `[${timestamp}] Return result details:`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] - filePath: '${result.filePath}'`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] - duration: ${result.duration}ms`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] - fileSize: ${result.fileSize} bytes`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] - Result object type: ${typeof result}`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] - Result is truthy: ${!!result}`);
      hilog.info(DOMAIN, TAG, `[${timestamp}] ========== stopRecording() completed, returning valid result ==========`);
      return result;
    } catch (error) {
      hilog.error(DOMAIN, TAG, `[${timestamp}] stopRecording() execution failed: ${JSON.stringify(error)}`);
      hilog.error(DOMAIN, TAG, `[${timestamp}] Error stack: ${error instanceof Error ? error.stack : 'No stack trace'}`);
      
      // å°è¯•é‡æ–°åˆ›å»ºå½•éŸ³å™¨
      try {
        hilog.info(DOMAIN, TAG, `[${timestamp}] Attempting to recreate recorder`);
        await this.createRecorder();
        this.recordState = RecordState.IDLE;
        this.notifyStateChange(this.recordState);
        hilog.info(DOMAIN, TAG, `[${timestamp}] Recorder recreated successfully`);
      } catch (createError) {
        hilog.error(DOMAIN, TAG, `[${timestamp}] Failed to recreate recorder: ${JSON.stringify(createError)}`);
      }
      throw new Error(`Failed to stop recording: ${JSON.stringify(error)}`);
    }
  }

  /**
   * å–æ¶ˆå½•åˆ¶
   */
  public async cancelRecording(): Promise<void> {
    if (!this.audioRecorder) {
      throw new Error("Recorder not initialized");
    }

    try {
      await this.audioRecorder.stop();
      
      // åˆ é™¤å½•åˆ¶æ–‡ä»¶
      if (this.currentFilePath && await fileIo.access(this.currentFilePath)) {
        await fileIo.unlink(this.currentFilePath);
        hilog.info(DOMAIN, TAG, `Deleted cancelled recording file: ${this.currentFilePath}`);
      }
      
      // é‡æ–°åˆ›å»ºå½•éŸ³å™¨ä»¥ä¾¿ä¸‹æ¬¡ä½¿ç”¨
      await this.createRecorder();
      this.recordState = RecordState.IDLE;
      this.notifyStateChange(this.recordState);
      
      this.currentFilePath = "";
      this.recordDuration = 0;
      
      hilog.info(DOMAIN, TAG, 'Recording cancelled');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to cancel recording: ${JSON.stringify(error)}`);
      // å°è¯•é‡æ–°åˆ›å»ºå½•éŸ³å™¨
      try {
        await this.createRecorder();
        this.recordState = RecordState.IDLE;
        this.notifyStateChange(this.recordState);
      } catch (createError) {
        hilog.error(DOMAIN, TAG, `Failed to recreate recorder after cancel error: ${JSON.stringify(createError)}`);
      }
      throw new Error(`Failed to cancel recording: ${JSON.stringify(error)}`);
    }
  }

  /**
   * è·å–å½•åˆ¶é…ç½®
   */
  private async getRecordConfig(): Promise<media.AVRecorderConfig> {
    const filePath = await this.generateFilePath();
    this.currentFilePath = filePath;
    this.recordStartTime = Date.now();
    this.recordDuration = 0;
    
    hilog.info(DOMAIN, TAG, `Generated file path: ${filePath}`);
    
    const config = {
      audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
      audioEncoder: media.CodecMimeType.AUDIO_AAC,
      audioEncodeBitRate: 128000,
      audioSampleRate: 44100,
      numberOfChannels: 2,
      format: media.ContainerFormatType.CFT_MPEG_4A,
      url: `file://${filePath}`,
      profile: {
        audioBitrate: 128000,
        audioChannels: 2,
        audioCodec: media.CodecMimeType.AUDIO_AAC,
        audioSampleRate: 44100,
        fileFormat: media.ContainerFormatType.CFT_MPEG_4A
      }
    } as media.AVRecorderConfig;
    
    hilog.info(DOMAIN, TAG, `Record config created: ${JSON.stringify(config)}`);
    return config;
  }

  /**
   * ç”Ÿæˆæ–‡ä»¶è·¯å¾„
   */
  private async generateFilePath(fileName?: string): Promise<string> {
    if (!this.context) {
      throw new Error("Context not initialized");
    }

    const timestamp = Date.now();
    const name = fileName || `audio_${timestamp}`;
    const filesDir = this.context.filesDir;
    const audioDir = `${filesDir}/audio`;
    
    // ç¡®ä¿éŸ³é¢‘ç›®å½•å­˜åœ¨
    if (!await fileIo.access(audioDir)) {
      await fileIo.mkdir(audioDir);
    }
    
    return `${audioDir}/${name}.m4a`;
  }

  /**
   * è·å–æ–‡ä»¶å¤§å°
   */
  private async getFileSize(filePath: string): Promise<number> {
    try {
      if (await fileIo.access(filePath)) {
        const stat = await fileIo.stat(filePath);
        return stat.size;
      }
      return 0;
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to get file size: ${JSON.stringify(error)}`);
      return 0;
    }
  }

  /**
   * å¼€å§‹æ—¶é•¿è®¡æ—¶å™¨
   */
  private startDurationTimer(): void {
    this.stopDurationTimer(); // ç¡®ä¿æ²¡æœ‰é‡å¤çš„è®¡æ—¶å™¨
    
    this.durationTimer = setInterval(() => {
      if (this.recordState === RecordState.RECORDING) {
        this.recordDuration = Date.now() - this.recordStartTime;
        this.notifyDurationUpdate(this.recordDuration);
      } else {
        this.stopDurationTimer();
      }
    }, 100); // æ¯100msæ›´æ–°ä¸€æ¬¡
  }

  /**
   * åœæ­¢æ—¶é•¿è®¡æ—¶å™¨
   */
  private stopDurationTimer(): void {
    if (this.durationTimer !== null) {
      clearInterval(this.durationTimer);
      this.durationTimer = null;
    }
  }

  /**
   * å¼€å§‹æŒ¯å¹…æ£€æµ‹
   */
  private startAmplitudeDetection(): void {
    this.stopAmplitudeDetection(); // ç¡®ä¿æ²¡æœ‰é‡å¤çš„æ£€æµ‹å™¨
    
    this.amplitudeTimer = setInterval(() => {
      if (this.recordState === RecordState.RECORDING) {
        const currentTime = Date.now();
        const timeDiff = currentTime - this.lastAmplitudeTime;
        
        // ç”ŸæˆæŒ¯å¹…æ•°æ®
        let amplitude = 0;
        if (timeDiff > 50) { // æ¯50msæ›´æ–°ä¸€æ¬¡
          if (DevConfig.isDevMode()) {
            // å¼€å‘æ¨¡å¼ï¼šä½¿ç”¨é…ç½®çš„æ¨¡æ‹ŸæŒ¯å¹…æ•°æ®
            amplitude = DevConfig.generateMockAmplitude();
            DevUtils.devLog(TAG, `æ¨¡æ‹ŸæŒ¯å¹…ï¼š${amplitude.toFixed(2)}`);
          } else {
            // ç”Ÿäº§æ¨¡å¼ï¼šåŸºäºæ—¶é—´ç”Ÿæˆå˜åŒ–çš„æŒ¯å¹…å€¼ï¼Œæ¨¡æ‹ŸçœŸå®å½•éŸ³
            const baseAmplitude = 20 + Math.sin(currentTime / 1000) * 15;
            const randomVariation = (Math.random() - 0.5) * 30;
            amplitude = Math.max(0, Math.min(100, baseAmplitude + randomVariation));
          }
          
          this.lastAmplitudeTime = currentTime;
          this.notifyAmplitudeUpdate(amplitude);
        }
      } else {
        this.stopAmplitudeDetection();
      }
    }, DevConfig.isDevMode() ? DevConfig.getMockRecordingConfig().amplitudeUpdateFrequency : 50); // æ ¹æ®æ¨¡å¼è°ƒæ•´æ›´æ–°é¢‘ç‡
  }

  /**
   * åœæ­¢æŒ¯å¹…æ£€æµ‹
   */
  private stopAmplitudeDetection(): void {
    if (this.amplitudeTimer !== null) {
      clearInterval(this.amplitudeTimer);
      this.amplitudeTimer = null;
    }
  }

  // ==================== ç›‘å¬å™¨ç®¡ç† ====================

  /**
   * è®¾ç½®çŠ¶æ€å˜åŒ–å›è°ƒï¼ˆå‘åå…¼å®¹æ–¹æ³•ï¼‰
   */
  public setStateChangeCallback(callback: (state: RecordState) => void): void {
    this.addStateChangeListener(callback);
  }

  /**
   * è®¾ç½®æ—¶é•¿æ›´æ–°å›è°ƒï¼ˆå‘åå…¼å®¹æ–¹æ³•ï¼‰
   */
  public setDurationCallback(callback: (duration: number) => void): void {
    this.addDurationUpdateListener(callback);
  }

  /**
   * è®¾ç½®æŒ¯å¹…å›è°ƒï¼ˆå‘åå…¼å®¹æ–¹æ³•ï¼‰
   */
  public setAmplitudeCallback(callback: (amplitude: number) => void): void {
    this.addAmplitudeListener(callback);
  }

  /**
   * è®¾ç½®é”™è¯¯å›è°ƒï¼ˆå‘åå…¼å®¹æ–¹æ³•ï¼‰
   */
  public setErrorCallback(callback: (error: string) => void): void {
    this.addErrorListener((error: BusinessError) => {
      callback(error.message || "Unknown error");
    });
  }

  /**
   * æ·»åŠ çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public addStateChangeListener(listener: (state: RecordState) => void): void {
    this.stateChangeListeners.push(listener);
  }

  /**
   * ç§»é™¤çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public removeStateChangeListener(listener: (state: RecordState) => void): void {
    const index = this.stateChangeListeners.indexOf(listener);
    if (index > -1) {
      this.stateChangeListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ æ—¶é•¿æ›´æ–°ç›‘å¬å™¨
   */
  public addDurationUpdateListener(listener: (duration: number) => void): void {
    this.durationUpdateListeners.push(listener);
  }

  /**
   * ç§»é™¤æ—¶é•¿æ›´æ–°ç›‘å¬å™¨
   */
  public removeDurationUpdateListener(listener: (duration: number) => void): void {
    const index = this.durationUpdateListeners.indexOf(listener);
    if (index > -1) {
      this.durationUpdateListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ æŒ¯å¹…ç›‘å¬å™¨
   */
  public addAmplitudeListener(listener: (amplitude: number) => void): void {
    this.amplitudeListeners.push(listener);
  }

  /**
   * ç§»é™¤æŒ¯å¹…ç›‘å¬å™¨
   */
  public removeAmplitudeListener(listener: (amplitude: number) => void): void {
    const index = this.amplitudeListeners.indexOf(listener);
    if (index > -1) {
      this.amplitudeListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ é”™è¯¯ç›‘å¬å™¨
   */
  public addErrorListener(listener: (error: BusinessError) => void): void {
    this.errorListeners.push(listener);
  }

  /**
   * ç§»é™¤é”™è¯¯ç›‘å¬å™¨
   */
  public removeErrorListener(listener: (error: BusinessError) => void): void {
    const index = this.errorListeners.indexOf(listener);
    if (index > -1) {
      this.errorListeners.splice(index, 1);
    }
  }

  /**
   * é€šçŸ¥çŠ¶æ€å˜åŒ–
   */
  private notifyStateChange(state: RecordState): void {
    this.stateChangeListeners.forEach(listener => {
      try {
        listener(state);
      } catch (error) {
        hilog.error(DOMAIN, TAG, `Error in state change listener: ${JSON.stringify(error)}`);
      }
    });
  }

  /**
   * é€šçŸ¥æ—¶é•¿æ›´æ–°
   */
  private notifyDurationUpdate(duration: number): void {
    this.durationUpdateListeners.forEach(listener => {
      try {
        listener(duration);
      } catch (error) {
        hilog.error(DOMAIN, TAG, `Error in duration update listener: ${JSON.stringify(error)}`);
      }
    });
  }

  /**
   * é€šçŸ¥æŒ¯å¹…æ›´æ–°
   */
  private notifyAmplitudeUpdate(amplitude: number): void {
    this.amplitudeListeners.forEach(listener => {
      try {
        listener(amplitude);
      } catch (error) {
        hilog.error(DOMAIN, TAG, `Error in amplitude listener: ${JSON.stringify(error)}`);
      }
    });
  }

  /**
   * é€šçŸ¥é”™è¯¯
   */
  private notifyError(error: BusinessError): void {
    this.errorListeners.forEach(listener => {
      try {
        listener(error);
      } catch (error) {
        hilog.error(DOMAIN, TAG, `Error in error listener: ${JSON.stringify(error)}`);
      }
    });
  }

  // ==================== è·å–å™¨æ–¹æ³• ====================

  /**
   * è·å–å½“å‰å½•åˆ¶çŠ¶æ€
   */
  public getRecordState(): RecordState {
    return this.recordState;
  }

  /**
   * è·å–å½“å‰å½•åˆ¶æ—¶é•¿
   */
  public getCurrentDuration(): number {
    return this.recordDuration;
  }

  /**
   * è·å–å½“å‰æ–‡ä»¶è·¯å¾„
   */
  public getCurrentFilePath(): string {
    return this.currentFilePath;
  }

  /**
   * æ˜¯å¦æ­£åœ¨å½•åˆ¶
   */
  public isRecording(): boolean {
    return this.recordState === RecordState.RECORDING;
  }

  /**
   * æ˜¯å¦å·²æš‚åœ
   */
  public isPaused(): boolean {
    return this.recordState === RecordState.PAUSED;
  }

  /**
   * é‡Šæ”¾èµ„æº
   */
  public async release(): Promise<void> {
    try {
      if (this.audioRecorder) {
        await this.audioRecorder.release();
        this.audioRecorder = null;
      }
      
      // åœæ­¢æ‰€æœ‰è®¡æ—¶å™¨
      this.stopDurationTimer();
      this.stopAmplitudeDetection();
      
      // æ¸…ç©ºç›‘å¬å™¨
      this.stateChangeListeners = [];
      this.durationUpdateListeners = [];
      this.amplitudeListeners = [];
      this.errorListeners = [];
      
      this.recordState = RecordState.IDLE;
      this.currentFilePath = "";
      this.recordDuration = 0;
      
      hilog.info(DOMAIN, TAG, 'AudioRecorderService released');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to release AudioRecorderService: ${JSON.stringify(error)}`);
      throw new Error(`Failed to release AudioRecorderService: ${JSON.stringify(error)}`);
    }
  }
}